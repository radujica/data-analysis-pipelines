from copy import deepcopy

import numpy as np
import os
from grizzly.encoders import NumPyDecoder, NumPyEncoder
from grizzly.lazy_op import LazyOpResult
from weld.weldobject import WeldObject

from lazy_data import LazyData
from lazy_file import LazyFile


class LazyResult(LazyOpResult):
    """ Extension of LazyOpResult adding lazy data reading

    The optional parameters are all required when recording data from a lazy parser

    Parameters
    ----------
    expr : np.ndarray / WeldObject
        what shall be evaluated
    weld_type : WeldType
        of the elements
    dim : int
        dimensionality of data

    """
    # stores placeholder name -> lazy parser file handler ~ Dataset
    file_mapping = {}
    # stores Weld input names ~ _inpX -> raw data or lazy parser data ~ Variable
    input_mapping = {}
    # stores weld_ids (e.g. _inpX) -> WeldObject or raw; naive caching similar to Spark's .cache()
    intermediate_mapping = {}
    # counters for placeholder names
    _file_counter = 0
    _data_counter = 0
    _intermediate_counter = 0
    # whether to cache intermediate results
    _intermediate_cache_flag = False if os.getenv("LAZY_WELD_CACHE") == 'False' else True
    # whether to cache data from file once read
    _cache_flag = False if os.getenv("WELD_INPUT_CACHE") == 'False' else True
    _threads = int(os.getenv("WELD_NUMBER_THREADS")) if os.getenv("WELD_NUMBER_THREADS") is not None else 1
    _experimental = False if os.getenv("WELD_APPLY_EXPERIMENTAL") == 'False' else True

    def __init__(self, expr, weld_type, dim):
        super(LazyResult, self).__init__(expr, weld_type, dim)

    @staticmethod
    def _generate_id(file_or_data_str, readable_reference=None):
        id_ = '_%s_id' % file_or_data_str
        if file_or_data_str == 'file':
            id_ = '%s%s' % (id_, LazyResult._file_counter)
            LazyResult._file_counter += 1
        elif file_or_data_str == 'data':
            id_ = '%s%s' % (id_, LazyResult._data_counter)
            LazyResult._data_counter += 1
        else:  # intermediate
            id_ = '%s%s' % (id_, LazyResult._intermediate_counter)
            LazyResult._intermediate_counter += 1

        if readable_reference is not None:
            if not isinstance(readable_reference, (str, unicode)):
                raise TypeError('readable_reference must be a str')
            id_ = '%s_%s' % (id_, readable_reference)

        return id_

    @staticmethod
    def generate_file_id(readable_reference=None):
        """ Generate an id for a lazy file input

        Parameters
        ----------
        readable_reference : str, optional
            included in the id for a more readable id

        Returns
        -------
        str
            id

        """
        return LazyResult._generate_id('file', readable_reference)

    @staticmethod
    def generate_data_id(readable_reference=None):
        """ Generate an id for a lazy data input

        Typically a 1d array, such as a column from a table

        Parameters
        ----------
        readable_reference : str, optional
            included in the id for a more readable id

        Returns
        -------
        str
            id

        """
        return LazyResult._generate_id('data', readable_reference)

    @staticmethod
    def generate_intermediate_id(readable_reference=None):
        """ Generate an id for an intermediate result cache

        Typically a 1d array, such as a column from a table

        Parameters
        ----------
        readable_reference : str, optional
            included in the id for a more readable id

        Returns
        -------
        str
            id

        """
        return LazyResult._generate_id('intermediate', readable_reference)

    @staticmethod
    def _check_add_args(id_, class_, expected_class):
        if not isinstance(id_, (str, unicode)):
            raise TypeError('id should be of type string but received id "{}" of type "{}"'.format(id_, type(id_)))

        if not isinstance(class_, expected_class):
            raise TypeError('expected LazyFile or LazyData but received {}'.format(type(class_)))

    @staticmethod
    def register_lazy_file(file_id, lazy_file):
        """ Only method linking an id to a LazyFile

        Parameters
        ----------
        file_id : str
            expected to be generated by generate_file_id
        lazy_file : LazyFile
            an instance of a LazyFile, typically from a parser

        """
        LazyResult._check_add_args(file_id, lazy_file, LazyFile)
        LazyResult.file_mapping[str(file_id)] = lazy_file

    @staticmethod
    def register_lazy_data(weld_input_id, lazy_data):
        """ Only method linking an id to a LazyData

        Parameters
        ----------
        weld_input_id : str
            id generated by WeldObject.update when creating placeholder object
        lazy_data : LazyData
            an instance of a LazyData, typically from a parser

        """
        LazyResult._check_add_args(weld_input_id, lazy_data, LazyData)
        LazyResult.input_mapping[str(weld_input_id)] = lazy_data

    @staticmethod
    def register_intermediate_result(weld_input_id, lazy_result):
        """ Only method linking an id to a LazyResult

        Parameters
        ----------
        weld_input_id : str
            id generated by WeldObject.update when updating context
        lazy_result : LazyResult
            an instance of a LazyResult

        """
        LazyResult._check_add_args(weld_input_id, lazy_result, LazyResult)
        LazyResult.intermediate_mapping[str(weld_input_id)] = lazy_result

    def __repr__(self):
        return "{}(weld_type={}, dimension={})".format(self.__class__.__name__,
                                                       self.weld_type,
                                                       self.dim)

    def __str__(self):
        return str(self.expr)

    @staticmethod
    def retrieve_file(file_id):
        """ Returns the raw data associated with the file_id

        Intended to be used by a parser when reading a fragment of its data, such as a column.
        Using this method ensures the file once read is cached, especially for formats such as csv
        where reading a single column is not possible without passing the entire file (unlike netcdf4 which
        supports reading just a variable).

        Parameters
        ----------
        file_id : str
            expected to be generated by generate_file_id

        """
        data = LazyResult.file_mapping[file_id]
        # if LazyFile, it means it's the first time parsing it
        if isinstance(data, LazyFile):
            data = data.read_file()
            # cache only if flag allows it
            if LazyResult._cache_flag:
                LazyResult.file_mapping[file_id] = data

        return data

    @staticmethod
    def retrieve_data(weld_input_id):
        """ Returns the raw data associated with the data_id

        Used within evaluate; enables caching of the data read.

        Parameters
        ----------
        weld_input_id : str
            expected to be generated by generate_data_id

        """
        data = LazyResult.input_mapping[weld_input_id]
        # if LazyData, it means it's the first time parsing it
        if isinstance(data, LazyData):
            data = data.eager_read()
            # cache only if flag allows it
            if LazyResult._cache_flag:
                LazyResult.input_mapping[str(weld_input_id)] = data

        return data

    @staticmethod
    def fetch_intermediate_result(weld_input_id, n=None):
        """ Returns the raw data associated with the intermediate_id

        Parameters
        ----------
        weld_input_id : str
            the id generated during WeldObject.update
        n : int, optional
            if desiring the head of the data, n must be the number of rows
            required. If passed, there is no caching of the evaluated result

        """
        entry = LazyResult.intermediate_mapping[weld_input_id]

        # so has not yet been evaluated
        if isinstance(entry, LazyResult):
            # so we want eager subset of data, no cache!
            if n is not None:
                entry = entry.head(n)
            else:
                entry = entry.evaluate()
                if LazyResult._intermediate_cache_flag:
                    LazyResult.intermediate_mapping[weld_input_id] = entry

            return entry
        else:
            return entry

    @staticmethod
    def generate_placeholder_weld_object(data_id, encoder, decoder):
        """ Generates a WeldObject which will evaluate to the data
        represented by the placeholder

        Parameters
        ----------
        data_id : str
            expected from generate_data_id, yet not enforced
        encoder : WeldObjectEncoder
        decoder : WeldObjectDecoder

        Returns
        -------
        WeldObject
            with weld_code which would evaluate to the data itself

        """
        # create weld object which will represent this data
        weld_obj = WeldObject(encoder, decoder)
        # update the context of this WeldObject and retrieve the generated _inpX id; WeldObject._registry
        # will hence link this data_id to the _inpX id
        weld_input_id = weld_obj.update(data_id)
        # should always be a new object, else there's a bug somewhere
        assert weld_input_id is not None
        # the code is just the input
        weld_obj.weld_code = '%s' % weld_input_id

        return weld_obj, weld_input_id

    def evaluate(self, verbose=True, decode=True, passes=None, num_threads=1,
                 apply_experimental_transforms=False):

        num_threads = LazyResult._threads
        apply_experimental_transforms = LazyResult._experimental

        if isinstance(self.expr, WeldObject):
            # replace context values for every lazy recorded file input
            for key in self.expr.context.iterkeys():
                key = str(key)
                if key in LazyResult.input_mapping:
                    self.expr.context[key] = LazyResult.retrieve_data(key)
                elif LazyResult._intermediate_cache_flag:
                    if key in LazyResult.intermediate_mapping:
                        self.expr.context[key] = LazyResult.fetch_intermediate_result(key)

            return super(LazyResult, self).evaluate(verbose, decode, passes, num_threads, apply_experimental_transforms)
        else:
            return self.expr

    def update_columns(self, columns):
        """ Update the columns required from a lazy data source

        Parameters
        ----------
        columns : list of str
            which columns to not read anymore

        """
        # if it's raw data, nothing to do
        if isinstance(self.expr, WeldObject):
            for key in self.expr.context.iterkeys():
                key = str(key)
                # this will return either LazyData or raw data
                value = LazyResult.input_mapping[key]
                if key in LazyResult.input_mapping and isinstance(value, LazyData):
                    value.lazy_skip_columns(columns)

    # TODO: it is currently not possible to slice the self.expr after filters/sorting/etc. when its context has LazyData
    # would required perhaps a separate method, or just make it the library's responsibility
    def update_rows(self, slice_):
        """ Update the columns required from a lazy data source

        Parameters
        ----------
        slice_ : slice
            which subset of the data/rows to read

        """
        if isinstance(self.expr, np.ndarray):
            self.expr = self.expr[slice_]
        else:
            for key, value in self.expr.context.iteritems():
                key = str(key)
                if key in LazyResult.input_mapping:
                    # this should be either LazyData or raw data
                    data = LazyResult.input_mapping[key]
                    if isinstance(data, LazyData):
                        data.lazy_slice_rows(slice_)
                    elif isinstance(data, np.ndarray):
                        length = len(data)
                        # should only slice within bounds; hacky solution to avoid creating arrays len=0 by over-slice
                        if length > slice_.stop and length > slice_.start:
                            # TODO: this could be weld_slice, but then would need to also to evaluate when necessary
                            LazyResult.input_mapping[key] = data[slice_]
                elif LazyResult._intermediate_cache_flag:
                    if key in LazyResult.intermediate_mapping:
                        data = LazyResult.intermediate_mapping[key]
                        if isinstance(data, LazyResult):
                            data.update_rows(slice_)
                        else:
                            # data[0] is hacky cuz I know it's ndim > 1
                            length = len(data[0])
                            # should slice within bounds; hacky solution to avoid creating arrays len=0 by over-slice
                            if length > slice_.stop and length > slice_.start:
                                # TODO: this could be weld_slice, but then need to also check to evaluate when necessary
                                # hacky again
                                LazyResult.intermediate_mapping[key] = data[:, slice_]
                # must be raw, so slice it
                # TODO: this could be weld_slice, but then would need to also check to evaluate when necessary
                else:
                    self.expr.context[key] = value[slice_]

    def _copy(self):
        copy_expr = WeldObject(self.expr.encoder, self.expr.decoder)
        copy_expr.weld_code = self.expr.weld_code
        copy_expr.context = deepcopy(self.expr.context)
        copy_expr.dependencies = self.expr.dependencies.copy()
        copy_expr.argtypes = deepcopy(self.expr.argtypes)

        return LazyResult(copy_expr, self.weld_type, self.dim)

    def head(self, n=10):
        """ Eagerly read the first n rows of the data.

        Does not have side-effects, such as caching or WeldObject context changes.

        Parameters
        ----------
        n : int, optional
            how many rows to read

        """
        if isinstance(self.expr, np.ndarray):
            return self.expr[:n]
        else:
            # this should only be called knowing expr is a WeldObject
            assert isinstance(self.expr, WeldObject)

            # copy self to avoid side-effects
            copy = self._copy()

            # loop through context to identify placeholders AND replace with the take_n values
            for key, value in copy.expr.context.iteritems():
                key = str(key)
                # intermediate results return the n needed, however other raw data has not been sliced yet
                # which leads to different array lengths in the context; therefore, make sure they're the same length
                if isinstance(value, np.ndarray):
                    copy.expr.context[key] = value[:n]
                else:
                    if key in LazyResult.input_mapping:
                        # this could be either LazyData or raw
                        data = LazyResult.input_mapping[key]
                        if isinstance(data, LazyData):
                            data = data.eager_head(n)
                        elif isinstance(data, np.ndarray):
                            data = data[:n]
                        copy.expr.context[key] = data
                    elif LazyResult._intermediate_cache_flag:
                        if key in LazyResult.intermediate_mapping:
                            copy.expr.context[key] = LazyResult.fetch_intermediate_result(key, n)

            # I have absolutely no clue why I need to copy it to make sure the data is not corrupted somehow
            res = super(LazyResult, copy).evaluate()[:n]
            return np.copy(res)


def weld_subset(array, slice_):
    """ Return a subset of the input array

    Parameters
    ----------
    array : np.array or WeldObject
        1-dimensional array
    slice_ : slice
        subset to return

    Returns
    -------
    WeldObject
        representation of this computation

    """
    weld_obj = WeldObject(NumPyEncoder(), NumPyDecoder())

    array_var = weld_obj.update(array)
    if isinstance(array, WeldObject):
        array_var = array.obj_id
        weld_obj.dependencies[array_var] = array

    if slice_.step == 1:
        weld_template = """
        slice(
            %(array)s,
            %(slice_start)s,
            %(slice_stop)s
        )"""
    else:
        weld_template = """
        result(
            for(
                iter(%(array)s, %(slice_start)s, %(slice_stop)s, %(slice_step)s),
                appender,
                |b, i, n| 
                    merge(b, n)
            )  
        )"""

    weld_obj.weld_code = weld_template % {'array': array_var,
                                          'slice_start': 'i64(%s)' % slice_.start,
                                          'slice_stop': 'i64(%s)' % (slice_.stop - slice_.start),
                                          'slice_step': 'i64(%s)' % slice_.step}

    return weld_obj
