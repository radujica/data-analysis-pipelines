from grizzly.lazy_op import LazyOpResult, WeldObject


class InputMapping(object):
    """ Maps lazy data from file

    Currently only used to map the following:

    data_id : str
        an id for this input, generated by the implementing parsers; should not interfere with other parser names!
        see TODOs
    weld_input_name : str
        the _inpX name generated by WeldObject
    input_function : function
        to call when evaluating, bringing the data from file to memory (i.e. reading the file)
    input_function_args : tuple

    Returns
    -------
    InputMapping

    """
    def __init__(self):
        # TODO: data_id uniqueness should be enforced somewhere
        self.data_ids = []
        self.weld_input_names = []
        self.input_functions = []
        self.input_function_args = []

    def append(self, data_id, weld_input_name, read_input_function, read_input_function_args):
        self.data_ids.append(data_id)
        self.weld_input_names.append(weld_input_name)
        self.input_functions.append(read_input_function)
        self.input_function_args.append(read_input_function_args)


# attempt no. 1 in a common interface for lazy parsing
class LazyData(LazyOpResult):
    input_mapping = InputMapping()
    # cache the materialized, i.e. read, data; data_id -> data
    materialized_columns = {}

    # TODO: add here id generation(?) to remove the responsibility from the developers

    # TODO: maybe one could use LazyOpResult directly if data_id = None
    # if data_id is None it means data did not come from a file (or compatible one anyway)
    def __init__(self, expr, weld_type, dim, data_id=None, read_func=None, read_func_args=None):
        super(LazyData, self).__init__(expr, weld_type, dim)
        self.data_id = data_id

        if data_id is not None and data_id not in self.input_mapping.data_ids:
            array_var = WeldObject.generate_input_name(self.expr)
            self.input_mapping.append(data_id, array_var, read_func, read_func_args)

    def evaluate(self, verbose=True, decode=True, passes=None, num_threads=1,
                 apply_experimental_transforms=False):
        if isinstance(self.expr, WeldObject):
            # replace context values for every lazy recorded file input
            for weld_input in self.expr.context.keys():
                if weld_input in self.input_mapping.weld_input_names:
                    index = self.input_mapping.weld_input_names.index(weld_input)
                    # TODO: tests!
                    # TODO: make methods for input mapping
                    # TODO: cache materialized stuff
                    self.expr.context[weld_input] = \
                        self.input_mapping.input_functions[index](*self.input_mapping.input_function_args[index])

            return super(LazyData, self).evaluate(verbose, decode, passes, num_threads, apply_experimental_transforms)
        else:
            # there's no operation on the data, so just read and return
            if self.data_id is not None:
                index = self.input_mapping.data_ids.index(self.data_id)
                return self.input_mapping.input_functions[index](*self.input_mapping.input_function_args[index])
            # data did not come from file so already 'stored' in expr
            else:
                return self.expr
