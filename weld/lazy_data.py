from grizzly.lazy_op import LazyOpResult, WeldObject


# TODO: better solutions for recurring problem of having to always check LazyData or raw;
# maybe make container for all input, i.e. all raw data is wrapped in LazyOpResult?
# TODO: make an easier distinction between data that comes from file (LazyData) and non (currently still LazyData);
# maybe a higher up class from which LazyData and LazyOpResult inherit could do it; the input_mapping seems to be a
# better fit to WeldObject too
# TODO: figure out a better way to generate data_id's; perhaps a better 'DB'-like way to store the data also
class InputMapping(object):
    """ Maps lazy data from file

    Currently only used to map the following:

    data_id : str
        an id for a file input, generated by the implementing parsers whenever new data is introduced from file;
        should NOT coincide with id's generated by other parsers!
    weld_input_name : str
        the _inpX name generated by WeldObject
    input_function : function
        to call when evaluating, bringing the data from file to memory (i.e. reading the file)
    input_function_args : tuple
    materialized_data : np.ndarray or others
        starts by being None; as soon as it's read, it is cached here

    Returns
    -------
    InputMapping

    """
    def __init__(self):
        self.data_ids = []
        self.weld_input_names = []
        self.input_functions = []
        self.input_function_args = []
        self.materialized_data = []

    def append(self, data_id, weld_input_name, read_input_function, read_input_function_args, materialized_data=None):
        self.data_ids.append(data_id)
        self.weld_input_names.append(weld_input_name)
        self.input_functions.append(read_input_function)
        self.input_function_args.append(read_input_function_args)
        self.materialized_data.append(materialized_data)

    def read(self, index):
        """ Read data at index

        Requires the user to figure out which index is desired.

        Parameters
        ----------
        index : int
            the index where the function and its arguments to read from file are stored

        Returns
        -------
        data
            probably np.array

        """
        return self.input_functions[index](*self.input_function_args[index])

    def retrieve(self, index):
        """ Higher function that can also retrieve from cache

        Parameters
        ----------
        index : int
            the index where the function and its arguments to read from file are stored

        Returns
        -------
        data
            probably np.array

        """
        if self.materialized_data[index] is not None:
            return self.materialized_data[index]
        else:
            data = self.read(index)
            # cache it for later
            self.materialized_data[index] = data

            return data

    def update_input_function_args(self, index, args):
        """ Update the read function args

        Used for subset

        Parameters
        ----------
        index : int
            the index where the function and its arguments to read from file are stored
        args : tuple
            new args

        """
        self.input_function_args[index] = args


# TODO: a more general way to store object_id -> read_func & args (as in, whatever object extends lazydata)
# such that subset does NOT need to be applied to the entire pipeline for that input
class LazyData(LazyOpResult):
    """ Extension of LazyOpResult adding lazy data reading

    Parameters
    ----------
    expr : np.ndarray / WeldObject
        what shall be evaluated
    weld_type : WeldType
        of the elements
    dim : int
        dimensionality of data
    data_id : str
        given only by parsers to record the existence of new data from file; needs to be passed on
        to other LazyData children objects, e.g. when creating a pandas_weld.Series from netCDF4_weld.Variable
    read_func : func
        function to call if the data is required (evaluated)
    read_func_args : tuple
        any arguments the above function might require

    Returns
    -------
    LazyData

    """
    input_mapping = InputMapping()

    # TODO: maybe just store dtype too? not sure if there are any other than np.dtype and even if there are,
    # they could also be stored; if there are, all operations (e.g. cartesian product) would need to be updated anyway
    # TODO: storing the length could also be useful, e.g. like in cartesian
    def __init__(self, expr, weld_type, dim, data_id=None, read_func=None, read_func_args=None):
        super(LazyData, self).__init__(expr, weld_type, dim)
        self.data_id = data_id

        # only want to record new id's
        if data_id is not None and data_id not in self.input_mapping.data_ids:
            # if either is None, LazyData was created/used incorrectly
            if read_func is None or read_func_args is None:
                raise ValueError('Attempted to create LazyData by passing a data_id with no read functions')
            # need to record the weld_input id from WeldObject, so generate it here
            array_var = WeldObject.generate_input_name(self.expr)
            self.input_mapping.append(data_id, array_var, read_func, read_func_args)

    def evaluate(self, verbose=True, decode=True, passes=None, num_threads=1,
                 apply_experimental_transforms=False):
        if isinstance(self.expr, WeldObject):
            # replace context values for every lazy recorded file input
            for weld_input in self.expr.context.keys():
                if weld_input in self.input_mapping.weld_input_names:
                    index = self.input_mapping.weld_input_names.index(weld_input)
                    self.expr.context[weld_input] = self.input_mapping.retrieve(index)

            return super(LazyData, self).evaluate(verbose, decode, passes, num_threads, apply_experimental_transforms)
        else:
            # there's no operation on the data, so just read and return
            if self.data_id is not None:
                index = self.input_mapping.data_ids.index(self.data_id)
                return self.input_mapping.retrieve(index)
            # data did not come from file so already 'stored' in expr
            else:
                return self.expr
