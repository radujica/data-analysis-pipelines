from grizzly.lazy_op import LazyOpResult, WeldObject


# TODO: better solutions for recurring problem of having to always check LazyData or raw;
# maybe make container for all input, i.e. all raw data is wrapped in LazyOpResult?
# TODO: make an easier distinction between data that comes from file (LazyData) and non (currently still LazyData);
# maybe a higher up class from which LazyData and LazyOpResult inherit could do it; the input_mapping seems to be a
# better fit to WeldObject too
# TODO: (better) decouple netCDF4_weld and pandas_weld hence making pandas_weld getitem more generic;
# need an interface between parser and pandas; maybe store in lazydata which from parser the data came from?
# TODO: just remove dependency on grizzly, so also remove lazyOpResult ^
class InputMapping(object):
    """ Maps lazy data from file

    Currently only used to map the following:

    data_id : str
        an id for a file input, generated by the implementing parsers whenever new data is introduced from file;
        should NOT coincide with id's generated by other parsers!
    weld_input_name : str
        the _inpX name generated by WeldObject
    input_function : function
        to call when evaluating, bringing the data from file to memory (i.e. reading the file)
    input_function_args : tuple
    materialized_data : np.ndarray or others
        starts by being None; as soon as it's read, it is cached here

    Returns
    -------
    InputMapping

    """
    def __init__(self):
        self.data_ids = []
        self.weld_input_names = []
        self.input_functions = []
        self.input_function_args = []
        self.materialized_data = []

    def append(self, data_id, weld_input_name, read_input_function, read_input_function_args, materialized_data=None):
        self.data_ids.append(data_id)
        self.weld_input_names.append(weld_input_name)
        self.input_functions.append(read_input_function)
        self.input_function_args.append(read_input_function_args)
        self.materialized_data.append(materialized_data)

    def read(self, index):
        """ Read data at index

        Requires the user to figure out which index is desired.

        Parameters
        ----------
        index : int
            the index where the function and its arguments to read from file are stored

        Returns
        -------
        data
            probably np.array

        """
        return self.input_functions[index](*self.input_function_args[index])

    def retrieve(self, index):
        """ Higher function that can also retrieve from cache

        Note that using this won't allow different subsets of the data to be read; a weld_input will be
        permanently linked to this materialized data.

        Parameters
        ----------
        index : int
            the index where the function and its arguments to read from file are stored

        Returns
        -------
        data
            probably np.array

        """
        if self.materialized_data[index] is not None:
            return self.materialized_data[index]
        else:
            data = self.read(index)
            # cache it for later
            self.materialized_data[index] = data

            return data

    def update_input_function_args(self, index, args):
        """ Update the read function args

        Used for subset

        Parameters
        ----------
        index : int
            the index where the function and its arguments to read from file are stored
        args : tuple
            new args

        """
        self.input_function_args[index] = args


class LazyData(LazyOpResult):
    """ Extension of LazyOpResult adding lazy data reading

    Parameters
    ----------
    expr : np.ndarray / WeldObject
        what shall be evaluated
    weld_type : WeldType
        of the elements
    dim : int
        dimensionality of data
    data_id : str
        given only by parsers to record the existence of new data from file; needs to be passed on
        to other LazyData children objects, e.g. when creating a pandas_weld.Series from netCDF4_weld.Variable
    read_func : func
        function to call if the data is required (evaluated)
    read_func_args : tuple
        any arguments the above function might require

    Returns
    -------
    LazyData

    """
    input_mapping = InputMapping()

    _data_counter = 0

    # one can pass e.g. the column name at readable_reference for a more readable id
    @staticmethod
    def generate_id(readable_reference=None):
        data_id = '_data_id%d' % LazyData._data_counter
        LazyData._data_counter += 1
        if readable_reference is not None:
            if not isinstance(readable_reference, (str, unicode)):
                raise TypeError('readable_reference must be a str')

            data_id = '%s_%s' % (data_id, readable_reference)

        return data_id

    # TODO: maybe just store dtype too? not sure if there are any other than np.dtype and even if there are,
    # they could also be stored; if there are, all operations (e.g. cartesian product) would need to be updated anyway
    # TODO: storing the length could also be useful, e.g. like in cartesian
    def __init__(self, expr, weld_type, dim, data_id=None, read_func=None, read_func_args=None):
        super(LazyData, self).__init__(expr, weld_type, dim)
        self.data_id = data_id

        # only want to record new id's
        if data_id is not None and data_id not in self.input_mapping.data_ids:
            # if either is None, LazyData was created/used incorrectly
            if read_func is None or read_func_args is None:
                raise ValueError('Attempted to create LazyData by passing a data_id with no read functions')
            # ensure that this holds
            if not isinstance(expr, WeldObject):
                raise TypeError('LazyData from file must always have a WeldObject as expr')
            self.input_mapping.append(data_id, expr.weld_code, read_func, read_func_args)

    def evaluate(self, verbose=True, decode=True, passes=None, num_threads=1,
                 apply_experimental_transforms=False):
        if isinstance(self.expr, WeldObject):
            # replace context values for every lazy recorded file input
            for value in self.expr.context.values():
                if str(value) in self.input_mapping.data_ids:
                    index = self.input_mapping.data_ids.index(value)
                    self.expr.context[self.input_mapping.weld_input_names[index]] = self.input_mapping.retrieve(index)

            return super(LazyData, self).evaluate(verbose, decode, passes, num_threads, apply_experimental_transforms)
        else:
            return self.expr
